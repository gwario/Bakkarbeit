\chapter{State of the art / analysis of existing approaches}

This section presents an overview of the work relevant to program comprehension regarding the aim of the work.

\section{literature studies}

software evolution
software maintenance
program comprehension
structured approach and thorrow reading is the most efficient[cite]

\section{analysis}

selected work

\subsection{program comprehension strategies}

about the mental model building

\begin{itemize}
\item top down
\item bottom up
\item knowledgebased
\item systematic and as-needed
\item integrated approaches
\end{itemize}

\subsection{analysis to support program understanding}

Several analysis types

\subsubsection{dynamic analysis}

\begin{itemize}
\item about realtime/interactive vs post mortem
\item actual behavior
\item incomplete view \cite{Ball:1999:CDA:318774.318944}
\item observer effect \\
Andrews, J. (1997). Testing using log file analysis: tools, methods, and issues.
In Proc. International Conference on Automated Software Engineering (ASE), pages 157–
166. IEEE Computer Society Press
\item scalability \\
Zaidman, A. (2006). Scalability Solutions for Program Comprehension through Dynamic
Analysis. PhD thesis, University of Antwerp
\item debugging -> different kind of paradigms and languages and tools\\
see @incollection{reiss1993trace,
title={Trace-based debugging},
author={Reiss, Steven P},
booktitle={Automated and Algorithmic Debugging},
pages={305--314},
year={1993},
publisher={Springer}
}
\item about debugging
\item dataflow analysis(Backward Analysis)(not sufficient in demo) \\
	Darren C. Atkinson , William G. Griswold, Implementation Techniques for Efficient Data-Flow Analysis of Large Programs, Proceedings of the IEEE International Conference on Software Maintenance (ICSM'01), p.52, November 07-09, 2001
\end{itemize}

\subsubsection{static analysis}

complete view
no actual data present

\subsection{applicability to concatenative languages}

existing methods abstract(abstract like print debugging and stepping and so on) furthermore the abstraction of all those methods mentioned above
applicability for concatenative languages

\section{visualization to support program understanding maybe some examples(and tools)}

\begin{itemize}
\item sequence diagram
\item circular diagram and interactive interaction sequance diagram \cite{Cornelissen2009}
\item interaction diagrams (Jacobson, 1992)/ scenario diagrams (Koskimies and Mössenböck 1996)
\item information murals (Jerding and Stasko, 1998)
\item polymetric views (Ducasse et al., 2004)
\item fisheye views (suggested by George W. Furnas, 1986, and formulated by \cite{Storey:1995:GLA:647547.728600} and \cite{Sarkar:1994:GFV:198366.198384})
\item hierarchical edge bundling (Holten, 2006)
\item structural and behavioral views of object-oriented program (Kleyn and Gingrich, 1988)
\item matrix visualization and “execution pattern” notations \cite{Pauw98executionpatterns} to visualize traces in a scalable manner(De Pauw et al. 1993, 1994, 1998) 
\item architecture oriented visualization (Sefika et al. 1996)
\item a continuous sequence diagram, and the “information mural” (Jerding and Stasko, 1998)
\item architecture with dynamic information (Walker et al. 1998)
\item frequency spectrum analysis (Ball 1999)
\end{itemize}

\section{comparison and summary of existing approaches}

existing approaches for gforth/forth

\begin{itemize}
\item kgforth http://sourceforge.net/projects/kgforth/
\item existing methods(actual methods)
	\begin{itemize}
	\item \hl{factoring (http://en.wikipedia.org/wiki/Modular\_programming https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Factoring-Tutorial.html http://www.ultratechnology.com/Forth-factors.htm)} has to be considered during initial development
	\item dump
	\item . / type
	\item dbg
	\item see/ code-see
	\item \textasciitilde\textasciitilde
	\end{itemize}
\end{itemize}