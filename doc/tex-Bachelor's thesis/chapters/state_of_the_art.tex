\chapter{Analysis of existing approaches}

The focus here lies on so called E type software. E stands for evolving \cite{Cook:2006:ESS:1115566.1115567}, most of the real world software systems are type E. These systems are of particular interest since they underlie changes throughout their whole life cycle. Thus understanding existing and maybe not well documented code is crucial for maintenance.

\section{program comprehension}

Program comprehension can be gained through several approaches. First of all is reading the code.
In \cite{Basili:1997:EPR:257260.257262}, Basili et al. approach the concept of reading on a very fundamental level. The natural way to learn writing, is to learn to read first, the reading the forms a model for our writing.  His research shows that reading is most effective compared to testing. This suggests, that readability of code does impact the efficiency of failure discovery. The most important issues stated, is the fact that programming languages are learned the other way round. We first learn to write code and then learn to read it. Furthermore, the ability to read code properly is not properly addressed in education. The syntactical flexibility, forth provides compared to other languages(and paradigms), allows to achieve a very natural seeming reading experience. Thus our skills in natural languages could become in handy and make program reading and thus understanding even more efficient. This would in the end result in higher code quality in terms of failures and unexpected or unintended behavior.

Besides the actual reading, there emerged several strategies on how to understand a program\cite{Storey:1999:CDE:308936.308940}: \hl{evt hier nur auf \\cite{Storey:1999:CDE:308936.308940} oder \\cite{Storey:1997:PUT:832304.836998} verweisen?!}
\paragraph{Top down program comprehension} Using the top down strategy, the reader begins on the highest level of abstraction, the main purpose of the program and then builds a hierarchy by refining it into sub tasks until the lowest level of abstraction is reached.
\paragraph{Bottom up program comprehension} Using the bottom up strategy, the reader builds the mental model by grouping low level parts of code building high levels abstraction until the whole program is understood.
\paragraph{Knowledge based program comprehension} The knowledge based strategy, allows both, the bottom up and the top down approach. The assumption is, that programmers have a certain mental model of the software, this model is evolved by both refinement and abstraction.
\paragraph{Systematic and as-needed program comprehension} This strategy embodies detailed reading as well as only focusing on the code necessary to fulfill the task at hand.
\paragraph{Integrated approaches of program comprehension} This strategy allows freely switching between the top down, the bottom up and the knowledge based approach.
\\\\
As Storey et al.\cite{Storey:1999:CDE:308936.308940} points out, there are certain factors which influence the choice programmers take. Thus the programming environment should provide methods to support all the strategies.(See later section)
\\\\
Since software evolves throughout its whole life cycle, also the before mentioned mental model, the reader evolves, has to keep in sync with the software. This suggests, that it is essential to keep all types of artifacts(documentation, source level documentation, graphics,...) up to date.(See later section)

\section{analysis to support program understanding}

Several analysis types
\begin{itemize}
\item source code reading
\item documentation reading(everything except source code)
\item static analysis
\item dynamic analysis
\item post mortem analysis
\item realtime analysis
\end{itemize}

\subsection{dynamic analysis}

\begin{itemize}
\item about realtime/interactive vs post mortem
\item actual behavior
\item incomplete view \cite{Ball:1999:CDA:318774.318944}
\item observer effect \\
Andrews, J. (1997). Testing using log file analysis: tools, methods, and issues.
In Proc. International Conference on Automated Software Engineering (ASE), pages 157–
166. IEEE Computer Society Press
\item scalability \\
Zaidman, A. (2006). Scalability Solutions for Program Comprehension through Dynamic
Analysis. PhD thesis, University of Antwerp
\item debugging -> different kind of paradigms and languages and tools\\
see @incollection{reiss1993trace,
title={Trace-based debugging},
author={Reiss, Steven P},
booktitle={Automated and Algorithmic Debugging},
pages={305--314},
year={1993},
publisher={Springer}
}
\item about debugging
\item dataflow analysis(Backward Analysis)(not sufficient in demo) \\
	Darren C. Atkinson , William G. Griswold, Implementation Techniques for Efficient Data-Flow Analysis of Large Programs, Proceedings of the IEEE International Conference on Software Maintenance (ICSM'01), p.52, November 07-09, 2001
\end{itemize}

\subsection{static analysis}

Static analysis is ...[cite]... not running code.
Therefore and in contrast to dynamic analysis, it has the capability to provide a complete view of the software at hands. The drawback is that there is no actual data present and thus there is no mean of covering the actual data and follow its manipulation. ...[cite]
This makes it a most valuable tool for architecture, design, and algorithm analysis. ...[cite]

\section{applicability to concatenative languages}

existing methods abstract(abstract like print debugging and stepping and so on) furthermore the abstraction of all those methods mentioned above to find similarities and then adapt them to fit the characteristics of concatenative languages.
applicability for concatenative languages

\subsection{visualization to support program understanding maybe some examples(and tools)}

\begin{itemize}
\item sequence diagram
\item circular diagram and interactive interaction sequance diagram \cite{Cornelissen2009}
\item interaction diagrams (Jacobson, 1992)/ scenario diagrams (Koskimies and Mössenböck 1996)
\item information murals (Jerding and Stasko, 1998)
\item polymetric views (Ducasse et al., 2004)
\item fisheye views (suggested by George W. Furnas, 1986, and formulated by \cite{Storey:1995:GLA:647547.728600} and \cite{Sarkar:1994:GFV:198366.198384})
\item hierarchical edge bundling (Holten, 2006)
\item structural and behavioral views of object-oriented program (Kleyn and Gingrich, 1988)
\item matrix visualization and “execution pattern” notations \cite{Pauw98executionpatterns} to visualize traces in a scalable manner(De Pauw et al. 1993, 1994, 1998) 
\item architecture oriented visualization (Sefika et al. 1996)
\item a continuous sequence diagram, and the “information mural” (Jerding and Stasko, 1998)
\item architecture with dynamic information (Walker et al. 1998)
\item frequency spectrum analysis (Ball 1999)
\end{itemize}

\section{comparison and summary of existing approaches}

existing approaches for gforth/forth and relation to above mentioned stuff

\begin{itemize}
\item kgforth http://sourceforge.net/projects/kgforth/
\item existing methods(actual methods)
	\begin{itemize}
	\item factoring (http://en.wikipedia.org/wiki/Modular\_programming https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Factoring-Tutorial.html http://www.ultratechnology.com/Forth-factors.htm)
	\item aliasing
	\item organization of word lists
	\item source code documentation
	\item other documentation artifacts
	\item dump
	\item ., / and type
	\item dbg
	\item see and code-see
	\item \textasciitilde\textasciitilde
	\end{itemize}
\end{itemize}