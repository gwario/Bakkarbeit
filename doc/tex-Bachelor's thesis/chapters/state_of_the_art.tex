\chapter{Analysis of existing approaches}

The focus here lies on so called E type software. E stands for evolving \cite{Cook:2006:ESS:1115566.1115567}, most of the real world software systems are type E. These systems are of particular interest since they underlie changes throughout their whole life cycle. Thus understanding existing and maybe not well documented code is crucial for maintenance.

\section{program comprehension}

Program comprehension can be gained through several approaches. First of all is reading the code.
In \cite{Basili:1997:EPR:257260.257262}, Basili et al. approach the concept of reading on a very fundamental level. The natural way to learn writing, is to learn to read first, the reading the forms a model for our writing.  His research shows that reading is most effective compared to testing. This suggests, that readability of code does impact the efficiency of failure discovery. The most important issues stated, is the fact that programming languages are learned the other way round. We first learn to write code and then learn to read it. Furthermore, the ability to read code properly is not properly addressed in education. The syntactical flexibility, forth provides compared to other languages(and paradigms), allows to achieve a very natural seeming reading experience. Thus our skills in natural languages could become in handy and make program reading and thus understanding even more efficient. This would in the end result in higher code quality in terms of failures and unexpected or unintended behavior.

Besides the actual reading, there emerged several strategies on how to understand a program\cite{Storey:1999:CDE:308936.308940}: \\\hl{evt hier nur auf \\cite{Storey:1999:CDE:308936.308940} oder \\cite{Storey:1997:PUT:832304.836998} verweisen?!}
\subsubsection*{Top down program comprehension}
Using the top down strategy, the reader begins on the highest level of abstraction, the main purpose of the program and then builds a hierarchy by refining it into sub tasks until the lowest level of abstraction is reached.
\subsubsection*{Bottom up program comprehension} Using the bottom up strategy, the reader builds the mental model by grouping low level parts of code building high levels abstraction until the whole program is understood.
\subsubsection*{Knowledge based program comprehension} The knowledge based strategy, allows both, the bottom up and the top down approach. The assumption is, that programmers have a certain mental model of the software, this model is evolved by both refinement and abstraction.
\subsubsection*{Systematic and as-needed program comprehension} This strategy embodies detailed reading as well as only focusing on the code necessary to fulfill the task at hand.
\subsubsection*{Integrated approaches of program comprehension} This strategy allows freely switching between the top down, the bottom up and the knowledge based approach.
\\\\
As Storey et al.\cite{Storey:1999:CDE:308936.308940} points out, there are certain factors which influence the choice programmers take. Thus the programming environment should provide methods to support all the strategies.(See later section)
\\\\
Since software evolves throughout its whole life cycle, also the before mentioned mental model, the reader evolves, has to keep in sync with the software. This suggests, that it is essential to keep all types of artifacts(documentation, source level documentation, graphics,...) up to date.(See later section)

\section{Analysis to support program understanding}

Besides reading of the actual code, the source code and other textual documentation, there are also other methods to help increase program understanding.

\subsection{Dynamic analysis}

Dynamic analysis is performed on the image of a program, executed on a real or virtual processor. The advantage dynamic analysis is, due to the availability of the data to be manipulated, that the actual behavior of a program can be investigated. The major drawback here is that there exists only an incomplete view of the software at hand\cite{Ball:1999:CDA:318774.318944}. It is a very efficient way to evolve or correct the mental model of developers.
I will distinct here between two categories of dynamic analysis:
\hl{TODO... ???}
\begin{itemize}
\item interactive\\
	The characteristics of interactive(stepped debugging, interpretative execution) approaches, is that the program is still executing during the analysis and thus time is a critical factor. This makes some analysis methods like performance analysis impossible. In networked environment, timeouts can make interactive analysis very hard.
\item non interactive(real-time or post-mortem)\\
	In real-time analysis(log analysis, trace analysis), data changes very quickly, which can make the task of tracking execution scenarios very resource intensive. In contrast, in post-mortem analysis(log analysis, trace analysis), the processing of very large files becomes a problem.
\end{itemize}

\subsection{Static analysis}

Although this thesis focuses on dynamic analysis, for the sake of completeness, also static analysis should be mentioned here.
Static analysis is performed on the source code. Therefore and in contrast to dynamic analysis, it has the capability to provide a complete view of the software at hands. The drawback is that there is no actual data present and thus there are no means of covering the actual data follow and the manipulation of data.

\section{Applicability to concatenative languages}

\hl{hier werden die ausgewählten und verworfenen methode nur auf gelistet und erst in folgendne kapitelen benauer analysiert}

existing methods abstract(abstract like print debugging and stepping and so on) furthermore the abstraction of all those methods mentioned above to find similarities and then adapt them to fit the characteristics of concatenative languages.
applicability for concatenative languages

\subsection{Some visualization methods}

\begin{itemize}
\item sequence diagram
\item circular diagram and interactive interaction sequance diagram \cite{Cornelissen2009}
\item interaction diagrams (Jacobson, 1992)/ scenario diagrams (Koskimies and Mössenböck 1996)
\item information murals (Jerding and Stasko, 1998)
\item polymetric views (Ducasse et al., 2004)
\item fisheye views (suggested by George W. Furnas, 1986, and formulated by \cite{Storey:1995:GLA:647547.728600} and \cite{Sarkar:1994:GFV:198366.198384})
\item hierarchical edge bundling (Holten, 2006)
\item structural and behavioral views of object-oriented program (Kleyn and Gingrich, 1988)
\item matrix visualization and “execution pattern” notations \cite{Pauw98executionpatterns} to visualize traces in a scalable manner(De Pauw et al. 1993, 1994, 1998) 
\item architecture oriented visualization (Sefika et al. 1996)
\item a continuous sequence diagram, and the “information mural” (Jerding and Stasko, 1998)
\item architecture with dynamic information (Walker et al. 1998)
\item frequency spectrum analysis (Ball 1999)
\end{itemize}

\section{Existing approaches}

\subsection{Gforth/Forth}

In this section I'm going to present the tools Gforth/Forth provides to support program understanding and maintenance\footnote{For further tools see https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Programming-Tools.html\#Programming-Tools}.

\subsubsection*{Examining data and code}
Gforth provides several tools to display data as well as code which support program understanding and support maintenance.\\
For displaying data, the most important words are \emph{.}, \emph{.s}, \emph{."}, \emph{type} and \emph{dump}.\\
\emph{.} and \emph{.s} simply print out elements of the stack, there are also words to vizualize the other stacks.
The words \emph{."} and \emph{type} print out text. These can be utilized to print logging information.\\
Last but not least, \emph{dump} displays memory areas(address, hex and ascii).\\
\textasciitilde\textasciitilde\: prints the location of itself in the source-file(file and line number) as well as the data stack.\\
These are usable in interactive as well in non-interactive analysis.\\
There are also words to investigate the inner workings of other words. 
\emph{see} displays the definition of words written in forth. It can be used to quickly look at the behavior of words provided by gforth without looking into source-files. The use of \emph{see} and its relatives only makes sense in interactive analysis.

\subsubsection*{status.fs}
Status.fs is contained in gforth(since 0.7.0), it opens a separate xterm window, displaying the current number base, the float stack, the data stack and the current search order. The view is updated after each execution in the interpreter. Thus it is only useful for interactive analysis.

\subsubsection*{Stepping debugger}
\emph{dbg\footnote{For further information see: https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Debugging.html\#Debugging}}, the stepping debugger, supports among others, single step, step into, step over as well as break points. It displays the address of the word to be executed and the content of the data stack after its execution. The debugger is only usable for interactive analysis.

\subsubsection*{Assertions}
Assertions\footnote{See https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Assertions.html\#Assertions} can be used to verify that the program at a certain point is in a certain state. For example pre-conditions and post-conditions of words could be implemented. With the use of assertions, the code can be prevented from breaking during maintenance. The word \emph{assert(} starts the assertion, the following words until the \emph{)} is executed and has to leave a flag on the stack. If the flag is true, the asserted condition is meet, if false, the execution of the program ends and the location of the failed assertion is printed(source file and line number).\\
There are several assertion levels and by setting the \emph{assert-level}, assertions can be deactivated.

\subsubsection*{Organisational <irgendwas>}

other documentation artifacts

source code documentation(stack effect comments, word comments)

organization of word lists, naming strategies

factoring (http://en.wikipedia.org/wiki/Modular\_programming https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Factoring-Tutorial.html http://www.ultratechnology.com/Forth-factors.htm)
modularisazion

aliasing: achtung hier stößt man schnell auf philosophische fragen. aliasing kann sowohl in der einen als auch in der anderen richtugn betrieben werden. zu viel abstraktion entspricht nicht der philosphie von forth
	


\subsection{emacs forth-mode}

The emacs forth-mode(forth.el and gforth.el)

\subsection{Kgforth}

There has also been an afford to integrate some of those tools into an graphical development environment. The project is called Kgforth\footnote{http://sourceforge.net/projects/kgforth/: Kgforth is a simple IDE for the gforth interpreter/compiler for KDE 2.** 
It provides an editor, gforth window,debug and dump window, forth toolbar and menu.}, but its development seems to be discontinued.