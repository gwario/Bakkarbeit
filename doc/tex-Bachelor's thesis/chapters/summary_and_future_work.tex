\chapter{Summary and future work}
\label{chap:Summary}

The pure exploratory approach did not provide any information on the actual impact of the implemented and suggested solutions. The gathering of quantitative data and the formulation of hypotheses remains to be done in future works.

\hl{summary of what has been done and the subjective conclusion only on the implementation or also the suggestions?}

\section{comparison with related work}

Quiet some research has been done on the topic of program comprehension in the last decades, but most of it addressed object oriented or procedural languages. Since there is no standard way to model object orientation in Gforth/Forth, it is not possible to implement a general tool for visualization, similar to the existing methods. But these methods should be applicable in general. The research on trace visualization has proven to be very similar for concatenative languages since a program is also a concatenation of words. The closest thing to an development environment which provides interactive information from static or analysis, is kgforth. It is an integrated development environment for Gforth/Forth, which provides separate windows for debugging and dump output. But its development has been discontinued.

\section{discussion of open issues}

Concerning the implemented demo, most obvious is the lack of usability. First of all the second window turned out to be rather annoying, it would have been better to include the visualization within the Gforth window and record the trace in a standardized data structure in a separate file.
Another not yet addressed problem is the scalability of the view, the inefficient use of the screen real estate as well as the long rendering delay of postscript makes it unusable for very long traces. A possible solution would be to limit the displayed stack depth to a certain number since it is not encouraged to manipulate more than some of the uppermost stack elements. Or to limit the depth per word to the number of elements, which have been defined in the stack effect comment.

Another improvement would be the implementation of an interactive trace sequence view, like the "massive sequence" view implemented by \cite{Cornelissen:2008:ETA:1454787.1454981}, where in addition nested words as well as the stack state between arbitrary words can be hidden and displayed on demand. The introduction of "watch points" to reduce the visual noise and the size of the trace file could also address the scalability issue. But in general, postscript is probably not the best technology for displaying this data.

It is also not practical to compare two traces to each other. A visualization of several traces in a massive sequence view like manner where several traces are synchronized by word and differences are visualized by colors could solve this problem.

Due to the implementation of the trace recording within the debugger, it is not possible to collect traces of live systems. Neither is performance analysis possible while recording traces/debugging.
 
% \begin{itemize}
% \item nature of gforth
% 	\begin{itemize}
% 	\item interpretation/compilation mix(how to integrate the adhook changes between modes '[]')
% 	\item lack of dynamic information(return stack add -> wordname heuristic)
% 	\end{itemize}
% \end{itemize}

\section{further work to be done}

\begin{itemize}
\item how does software maintenance work in those languages?
\item ide
\item display of variable content
\item display of allocated memory areas
\item display of color diff with tooltip of previous values for stacks and memory areas
\item (better visualization of loops and control structures) is this even possible?
\item (display of the full program as a graph) is this even possible?
\item (customizable inspection depth) ?
\item type system for forth...see strongforth and the work of greg

\item static code analysis

v---- see previous chapter ----v
\item using a standard data type to store traces
\item stack depth per word
\end{itemize}


% \hl{TODO: PASST NICHT MEHR\\ To properly approach the stated problem, the first thing is to understand if and when program understanding is required. Although intuitively obvious, this section will discuss both, since the approach which developers use to understand programs, can be very different during the life cycle of software. Next, the means of understanding programs itself is investigated. Third, the nature of concatenative languages and in particular gforth/forth will be investigated.}

kind of an \sout{ide} development environment\\
light table ide(js) continuous reverse engineering idea of \cite{Muller:2000:RER:336512.336526} to provide immediate response of the systems output... although probably not applicable or very time consuming in setup(or not more than integration testing...) for most industrial scale software\\
eclipse ide(java)


conclusion like what i contributed to the community!!\\


\section{further reading}

work on program comprehension of concatenative languages
good overview of the field \cite{Canfora:2011:ACS:1924421.1924451} and \cite{Cornelissen2009}