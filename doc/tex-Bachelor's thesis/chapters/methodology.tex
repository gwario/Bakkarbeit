\newglossaryentry{ACM}
{
  name={ACM},
  description={ACM is widely recognized as the premier membership organization for computing professionals, delivering resources that advance computing as a science and a profession; enable professional development; and promote policies and research that benefit society.}
}

% \newacronym{acm}{ACM}{Association for Computing Machinery}

\chapter{Methodology}
\label{chap:Methodology}

This chapter contains the methodological methods used to approach the topic of this thesis.

I will use a qualitative approach. In Chapter \ref{chap:StateOfTheArt}, I will gain an overview of program comprehension and it's techniques in general and I will summarize the currently available techniques for Gforth/Forth. The main resources for that was \cite{Cornelissen:2009:SSP:1638616.1639301} and the keyword search on the \gls{ACM} digital library\footnote{\url{http://dl.acm.org/}}.
Since I will investigate the applicability to Gforth/Forth of only a handful of concrete techniques, I used the following criteria for selection:
\begin{itemize}
\item Graphical visualization 
\item Applicable to imperative languages(procedural and object oriented)
\item Behavioral analysis
\item Suitable for trace visualization
\end{itemize}
One probable issue, introduced by the initial keyword search, is the lack of previous knowledge on the topic of program understanding, trace visualization and concatenative languages. Another one is the lack of experience with Gforth/Forth.

In Chapter \ref{chap:Results}, I will analyze the graphics which would be produced as a result of the selected techniques.
First, I will introduce the software on which I applied those techniques. The software was chosen with the following criteria in mind:
\begin{itemize}
\item Size: The software should consist of at least hundred kilobytes of source code.
\item Complexity: It should have at least a medium level of complexity.
\item Practicality: It should solve a real problem.
\end{itemize}
Since software characteristics can vary greatly depending on the domain, the selection of only one program might not be meaningful enough to confirm, whether or not a certain technique is useful for arbitrary Gforth/Forth programs.
Second, I will analyze the graphics in an exploratory fashion and propose modifications of these techniques to improve their usefulness. Due to the lack of automated implementations of the selected techniques for Gforth/Forth, I will produce these graphics manually.
Third, I will introduce the prototype of an enhancement for the Gforth step-debugger which was implement in the course of this thesis and discuss its usefulness.

It is obvious, that due to the chosen methodology, there will be no quantitative confirmation for the usefulness of the techniques under investigation. Due to the limited selection of techniques, there may be other methods which are invaluable to program comprehension, but are not covered by this thesis.